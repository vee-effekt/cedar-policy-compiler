// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_lower.isle
// - src/isa/pulley_shared/inst.isle
// - src/isa/pulley_shared/lower.isle
// - /Users/lapwing/Desktop/cedar/cedar-policy-compiler/target/debug/build/cranelift-codegen-bac6f6faf8f17f86/out/clif_lower.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> i32;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_as_i8(&mut self, arg0: u8) -> i8;
    fn u8_as_u32(&mut self, arg0: u8) -> u32;
    fn u8_as_u64(&mut self, arg0: u8) -> u64;
    fn u16_as_i16(&mut self, arg0: u16) -> i16;
    fn u16_as_u32(&mut self, arg0: u16) -> u32;
    fn u16_as_u64(&mut self, arg0: u16) -> u64;
    fn u64_as_u8(&mut self, arg0: u64) -> u8;
    fn u64_as_u16(&mut self, arg0: u64) -> u16;
    fn u64_as_i64(&mut self, arg0: u64) -> i64;
    fn u16_try_from_u64(&mut self, arg0: u64) -> Option<u16>;
    fn u32_try_from_u64(&mut self, arg0: u64) -> Option<u32>;
    fn i8_try_from_u64(&mut self, arg0: u64) -> Option<i8>;
    fn i16_try_from_u64(&mut self, arg0: u64) -> Option<i16>;
    fn i32_try_from_u64(&mut self, arg0: u64) -> Option<i32>;
    fn u32_as_u64(&mut self, arg0: u32) -> u64;
    fn i32_as_i64(&mut self, arg0: i32) -> i64;
    fn i64_as_u64(&mut self, arg0: i64) -> u64;
    fn i64_neg(&mut self, arg0: i64) -> i64;
    fn i8_neg(&mut self, arg0: i8) -> i8;
    fn u128_as_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_as_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u32_as_u16(&mut self, arg0: u32) -> Option<u16>;
    fn u64_as_i32(&mut self, arg0: u64) -> i32;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_shl(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_shr(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_and(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_shl(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_shl(&mut self, arg0: u64, arg1: u64) -> u64;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_le(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn i64_shr(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_ctz(&mut self, arg0: i64) -> i64;
    fn i64_sextend_u64(&mut self, arg0: Type, arg1: u64) -> i64;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn i64_is_zero(&mut self, arg0: i64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn u128_replicated_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_replicated_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u32_replicated_u16(&mut self, arg0: u64) -> Option<u64>;
    fn u16_replicated_u8(&mut self, arg0: u64) -> Option<u8>;
    fn f16_min(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_max(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_neg(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_abs(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_copysign(&mut self, arg0: Ieee16, arg1: Ieee16) -> Ieee16;
    fn f32_add(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sub(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_mul(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_div(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sqrt(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_ceil(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_floor(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_trunc(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_nearest(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_min(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_max(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_neg(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_abs(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_copysign(&mut self, arg0: Ieee32, arg1: Ieee32) -> Ieee32;
    fn f64_add(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sub(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_mul(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_div(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sqrt(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_ceil(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_floor(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_trunc(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_nearest(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_min(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_max(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_neg(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_abs(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_copysign(&mut self, arg0: Ieee64, arg1: Ieee64) -> Ieee64;
    fn f128_min(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_max(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_neg(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_abs(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_copysign(&mut self, arg0: Ieee128, arg1: Ieee128) -> Ieee128;
    fn ty_umin(&mut self, arg0: Type) -> u64;
    fn ty_umax(&mut self, arg0: Type) -> u64;
    fn ty_smin(&mut self, arg0: Type) -> u64;
    fn ty_smax(&mut self, arg0: Type) -> u64;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_count(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn ty_half_lanes(&mut self, arg0: Type) -> Option<Type>;
    fn ty_half_width(&mut self, arg0: Type) -> Option<Type>;
    fn ty_equal(&mut self, arg0: Type, arg1: Type) -> bool;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn intcc_swap_args(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_complement(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_without_eq(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_swap_args(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_complement(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64_extract(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_16_or_32(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_16_to_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_addr64(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u16_from_ieee16(&mut self, arg0: Ieee16) -> u16;
    fn u32_from_ieee32(&mut self, arg0: Ieee32) -> u32;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_i32(&mut self, arg0: Offset32) -> i32;
    fn i32_to_offset32(&mut self, arg0: i32) -> Offset32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    fn value_reg(&mut self, arg0: Reg) -> ValueRegs;
    fn writable_value_reg(&mut self, arg0: WritableReg) -> WritableValueRegs;
    fn value_regs(&mut self, arg0: Reg, arg1: Reg) -> ValueRegs;
    fn writable_value_regs(&mut self, arg0: WritableReg, arg1: WritableReg) -> WritableValueRegs;
    fn value_regs_invalid(&mut self) -> ValueRegs;
    fn output_none(&mut self) -> InstOutput;
    fn output(&mut self, arg0: ValueRegs) -> InstOutput;
    fn output_pair(&mut self, arg0: ValueRegs, arg1: ValueRegs) -> InstOutput;
    fn output_builder_new(&mut self) -> InstOutputBuilder;
    fn output_builder_push(&mut self, arg0: &InstOutputBuilder, arg1: ValueRegs) -> Unit;
    fn output_builder_finish(&mut self, arg0: &InstOutputBuilder) -> InstOutput;
    fn temp_writable_reg(&mut self, arg0: Type) -> WritableReg;
    fn is_valid_reg(&mut self, arg0: Reg) -> bool;
    fn invalid_reg(&mut self) -> Reg;
    fn mark_value_used(&mut self, arg0: Value) -> Unit;
    fn put_in_reg(&mut self, arg0: Value) -> Reg;
    fn put_in_regs(&mut self, arg0: Value) -> ValueRegs;
    fn ensure_in_vreg(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn value_regs_get(&mut self, arg0: ValueRegs, arg1: usize) -> Reg;
    fn value_regs_len(&mut self, arg0: ValueRegs) -> usize;
    fn preg_to_reg(&mut self, arg0: PReg) -> Reg;
    fn add_range_fact(&mut self, arg0: Reg, arg1: u16, arg2: u64, arg3: u64) -> Reg;
    fn single_target(&mut self, arg0: &MachLabelSlice) -> Option<MachLabel>;
    fn two_targets(&mut self, arg0: &MachLabelSlice) -> Option<(MachLabel, MachLabel)>;
    fn jump_table_targets(&mut self, arg0: &MachLabelSlice)
        -> Option<(MachLabel, BoxVecMachLabel)>;
    fn jump_table_size(&mut self, arg0: &BoxVecMachLabel) -> u32;
    fn value_list_slice(&mut self, arg0: ValueList) -> ValueSlice;
    fn value_slice_empty(&mut self, arg0: ValueSlice) -> Option<()>;
    fn value_slice_unwrap(&mut self, arg0: ValueSlice) -> Option<(Value, ValueSlice)>;
    fn value_slice_len(&mut self, arg0: ValueSlice) -> usize;
    fn value_slice_get(&mut self, arg0: ValueSlice, arg1: usize) -> Value;
    fn writable_reg_to_reg(&mut self, arg0: WritableReg) -> Reg;
    fn inst_results(&mut self, arg0: Inst) -> ValueSlice;
    fn value_is_unused(&mut self, arg0: Value) -> bool;
    fn first_result(&mut self, arg0: Inst) -> Option<Value>;
    fn inst_data(&mut self, arg0: Inst) -> InstructionData;
    fn def_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn i32_from_iconst(&mut self, arg0: Value) -> Option<i32>;
    fn i64_from_iconst(&mut self, arg0: Value) -> Option<i64>;
    fn zero_value(&mut self, arg0: Value) -> Option<Value>;
    fn is_sinkable_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn maybe_uextend(&mut self, arg0: Value) -> Option<Value>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn emit(&mut self, arg0: &MInst) -> Unit;
    fn sink_inst(&mut self, arg0: Inst) -> Unit;
    fn emit_u64_le_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u128_le_const(&mut self, arg0: u128) -> VCodeConstant;
    fn const_to_vconst(&mut self, arg0: Constant) -> VCodeConstant;
    fn tls_model(&mut self, arg0: Type) -> TlsModel;
    fn tls_model_is_elf_gd(&mut self) -> Option<Unit>;
    fn tls_model_is_macho(&mut self) -> Option<Unit>;
    fn tls_model_is_coff(&mut self) -> Option<Unit>;
    fn preserve_frame_pointers(&mut self) -> Option<Unit>;
    fn stack_switch_model(&mut self) -> Option<StackSwitchModel>;
    fn box_external_name(&mut self, arg0: ExternalName) -> BoxExternalName;
    fn func_ref_data(&mut self, arg0: FuncRef) -> (SigRef, ExternalName, RelocDistance);
    fn symbol_value_data(
        &mut self,
        arg0: GlobalValue,
    ) -> Option<(ExternalName, RelocDistance, i64)>;
    fn reloc_distance_near(&mut self, arg0: RelocDistance) -> Option<()>;
    fn vec_mask_from_immediate(&mut self, arg0: Immediate) -> Option<VecMask>;
    fn u128_from_immediate(&mut self, arg0: Immediate) -> Option<u128>;
    fn vconst_from_immediate(&mut self, arg0: Immediate) -> Option<VCodeConstant>;
    fn u128_from_constant(&mut self, arg0: Constant) -> Option<u128>;
    fn u64_from_constant(&mut self, arg0: Constant) -> Option<u64>;
    fn shuffle64_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8)>;
    fn shuffle32_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8, u8, u8)>;
    fn shuffle16_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8, u8, u8, u8, u8, u8, u8)>;
    fn only_writable_reg(&mut self, arg0: WritableValueRegs) -> Option<WritableReg>;
    fn writable_regs_get(&mut self, arg0: WritableValueRegs, arg1: usize) -> WritableReg;
    fn abi_num_args(&mut self, arg0: Sig) -> usize;
    fn abi_get_arg(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_num_rets(&mut self, arg0: Sig) -> usize;
    fn abi_get_ret(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_ret_arg(&mut self, arg0: Sig) -> Option<ABIArg>;
    fn abi_no_ret_arg(&mut self, arg0: Sig) -> Option<()>;
    fn abi_unwrap_ret_area_ptr(&mut self) -> Reg;
    fn abi_stackslot_addr(&mut self, arg0: WritableReg, arg1: StackSlot, arg2: Offset32) -> MInst;
    fn abi_dynamic_stackslot_addr(&mut self, arg0: WritableReg, arg1: DynamicStackSlot) -> MInst;
    fn abi_arg_only_slot(&mut self, arg0: &ABIArg) -> Option<ABIArgSlot>;
    fn abi_arg_implicit_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, Type)>;
    fn real_reg_to_reg(&mut self, arg0: RealReg) -> Reg;
    fn real_reg_to_writable_reg(&mut self, arg0: RealReg) -> WritableReg;
    fn gen_move(&mut self, arg0: Type, arg1: WritableReg, arg2: Reg) -> MInst;
    fn gen_return(&mut self, arg0: ValueSlice) -> Unit;
    fn gen_return_call(
        &mut self,
        arg0: SigRef,
        arg1: ExternalName,
        arg2: RelocDistance,
        arg3: ValueSlice,
    ) -> InstOutput;
    fn gen_return_call_indirect(
        &mut self,
        arg0: SigRef,
        arg1: Value,
        arg2: ValueSlice,
    ) -> InstOutput;
    fn safe_divisor_from_imm64(&mut self, arg0: Type, arg1: Imm64) -> Option<u64>;
    fn xreg_new(&mut self, arg0: Reg) -> XReg;
    fn writable_xreg_new(&mut self, arg0: WritableReg) -> WritableXReg;
    fn writable_xreg_to_xreg(&mut self, arg0: WritableXReg) -> XReg;
    fn writable_xreg_to_writable_reg(&mut self, arg0: WritableXReg) -> WritableReg;
    fn xreg_to_reg(&mut self, arg0: XReg) -> Reg;
    fn freg_new(&mut self, arg0: Reg) -> FReg;
    fn writable_freg_new(&mut self, arg0: WritableReg) -> WritableFReg;
    fn writable_freg_to_freg(&mut self, arg0: WritableFReg) -> FReg;
    fn writable_freg_to_writable_reg(&mut self, arg0: WritableFReg) -> WritableReg;
    fn freg_to_reg(&mut self, arg0: FReg) -> Reg;
    fn vreg_new(&mut self, arg0: Reg) -> VReg;
    fn writable_vreg_new(&mut self, arg0: WritableReg) -> WritableVReg;
    fn writable_vreg_to_vreg(&mut self, arg0: WritableVReg) -> VReg;
    fn writable_vreg_to_writable_reg(&mut self, arg0: WritableVReg) -> WritableReg;
    fn vreg_to_reg(&mut self, arg0: VReg) -> Reg;
    fn sp_reg(&mut self) -> XReg;
    fn fp_reg(&mut self) -> XReg;
    fn lr_reg(&mut self) -> XReg;
    fn gen_call(
        &mut self,
        arg0: SigRef,
        arg1: ExternalName,
        arg2: RelocDistance,
        arg3: ValueSlice,
    ) -> InstOutput;
    fn gen_call_indirect(&mut self, arg0: SigRef, arg1: Value, arg2: ValueSlice) -> InstOutput;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
    fn size_hint(&self) -> (usize, Option<usize>) {
        (0, None)
    }
}

pub trait IntoContextIter {
    type Context;
    type Output;
    type IntoIter: ContextIter<Context = Self::Context, Output = Self::Output>;
    fn into_context_iter(self) -> Self::IntoIter;
}

pub trait Length {
    fn len(&self) -> usize;
}

impl<T> Length for std::vec::Vec<T> {
    fn len(&self) -> usize {
        std::vec::Vec::len(self)
    }
}

pub struct ContextIterWrapper<I, C> {
    iter: I,
    _ctx: std::marker::PhantomData<C>,
}
impl<I: Default, C> Default for ContextIterWrapper<I, C> {
    fn default() -> Self {
        ContextIterWrapper {
            iter: I::default(),
            _ctx: std::marker::PhantomData,
        }
    }
}
impl<I, C> std::ops::Deref for ContextIterWrapper<I, C> {
    type Target = I;
    fn deref(&self) -> &I {
        &self.iter
    }
}
impl<I, C> std::ops::DerefMut for ContextIterWrapper<I, C> {
    fn deref_mut(&mut self) -> &mut I {
        &mut self.iter
    }
}
impl<I: Iterator, C: Context> From<I> for ContextIterWrapper<I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: std::marker::PhantomData,
        }
    }
}
impl<I: Iterator, C: Context> ContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}
impl<I: IntoIterator, C: Context> IntoContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    type IntoIter = ContextIterWrapper<I::IntoIter, C>;
    fn into_context_iter(self) -> Self::IntoIter {
        ContextIterWrapper {
            iter: self.iter.into_iter(),
            _ctx: std::marker::PhantomData,
        }
    }
}
impl<T, E: Extend<T>, C> Extend<T> for ContextIterWrapper<E, C> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        self.iter.extend(iter);
    }
}
impl<L: Length, C> Length for ContextIterWrapper<L, C> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}

/// Internal type MultiReg: defined at src/prelude_lower.isle line 20.
#[derive(Clone, Debug)]
pub enum MultiReg {
    Empty,
    One { a: Reg },
    Two { a: Reg, b: Reg },
    Three { a: Reg, b: Reg, c: Reg },
    Four { a: Reg, b: Reg, c: Reg, d: Reg },
}

/// Internal type SideEffectNoResult: defined at src/prelude_lower.isle line 388.
#[derive(Clone, Debug)]
pub enum SideEffectNoResult {
    Inst {
        inst: MInst,
    },
    Inst2 {
        inst1: MInst,
        inst2: MInst,
    },
    Inst3 {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
    },
}

/// Internal type ProducesFlags: defined at src/prelude_lower.isle line 434.
#[derive(Clone, Debug)]
pub enum ProducesFlags {
    AlreadyExistingFlags,
    ProducesFlagsSideEffect { inst: MInst },
    ProducesFlagsTwiceSideEffect { inst1: MInst, inst2: MInst },
    ProducesFlagsReturnsReg { inst: MInst, result: Reg },
    ProducesFlagsReturnsResultWithConsumer { inst: MInst, result: Reg },
}

/// Internal type ConsumesAndProducesFlags: defined at src/prelude_lower.isle line 453.
#[derive(Clone, Debug)]
pub enum ConsumesAndProducesFlags {
    SideEffect { inst: MInst },
    ReturnsReg { inst: MInst, result: Reg },
}

/// Internal type ConsumesFlags: defined at src/prelude_lower.isle line 461.
#[derive(Clone, Debug)]
pub enum ConsumesFlags {
    ConsumesFlagsSideEffect {
        inst: MInst,
    },
    ConsumesFlagsSideEffect2 {
        inst1: MInst,
        inst2: MInst,
    },
    ConsumesFlagsReturnsResultWithProducer {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsTwiceReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        result: ValueRegs,
    },
    ConsumesFlagsFourTimesReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
        inst4: MInst,
        result: ValueRegs,
    },
}

/// Internal type MInst: defined at src/isa/pulley_shared/inst.isle line 10.
#[derive(Clone, Debug)]
pub enum MInst {
    Args {
        args: VecArgPair,
    },
    Rets {
        rets: VecRetPair,
    },
    Unwind {
        inst: UnwindInst,
    },
    BrTable {
        idx: XReg,
        default: MachLabel,
        targets: BoxVecMachLabel,
    },
    Trap {
        code: TrapCode,
    },
    TrapIf {
        cond: IntCC,
        size: OperandSize,
        src1: XReg,
        src2: XReg,
        code: TrapCode,
    },
    Nop,
    GetSpecial {
        dst: WritableXReg,
        reg: XReg,
    },
    Ret,
    LoadExtName {
        dst: WritableXReg,
        name: BoxExternalName,
        offset: i64,
    },
    Call {
        info: BoxCallInfo,
    },
    IndirectCall {
        info: BoxCallIndInfo,
    },
    IndirectCallHost {
        info: BoxCallInfo,
    },
    Jump {
        label: MachLabel,
    },
    BrIf {
        c: XReg,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    BrIfXeq32 {
        src1: XReg,
        src2: XReg,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    BrIfXneq32 {
        src1: XReg,
        src2: XReg,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    BrIfXslt32 {
        src1: XReg,
        src2: XReg,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    BrIfXslteq32 {
        src1: XReg,
        src2: XReg,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    BrIfXult32 {
        src1: XReg,
        src2: XReg,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    BrIfXulteq32 {
        src1: XReg,
        src2: XReg,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    Xmov {
        dst: WritableXReg,
        src: XReg,
    },
    Fmov {
        dst: WritableFReg,
        src: FReg,
    },
    Vmov {
        dst: WritableVReg,
        src: VReg,
    },
    Xconst8 {
        dst: WritableXReg,
        imm: i8,
    },
    Xconst16 {
        dst: WritableXReg,
        imm: i16,
    },
    Xconst32 {
        dst: WritableXReg,
        imm: i32,
    },
    Xconst64 {
        dst: WritableXReg,
        imm: i64,
    },
    Xadd32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xadd64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xeq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xneq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslt64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslteq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xult64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xulteq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xeq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xneq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslt32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslteq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xult32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xulteq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    LoadAddr {
        dst: WritableXReg,
        mem: Amode,
    },
    Load {
        dst: WritableReg,
        mem: Amode,
        ty: Type,
        flags: MemFlags,
        ext: ExtKind,
    },
    Store {
        mem: Amode,
        src: Reg,
        ty: Type,
        flags: MemFlags,
    },
    BitcastIntFromFloat32 {
        dst: WritableXReg,
        src: FReg,
    },
    BitcastIntFromFloat64 {
        dst: WritableXReg,
        src: FReg,
    },
    BitcastFloatFromInt32 {
        dst: WritableFReg,
        src: XReg,
    },
    BitcastFloatFromInt64 {
        dst: WritableFReg,
        src: XReg,
    },
    PushFrame,
    PopFrame,
    StackAlloc32 {
        amt: u32,
    },
    StackFree32 {
        amt: u32,
    },
}

/// Internal type Amode: defined at src/isa/pulley_shared/inst.isle line 138.
#[derive(Clone, Debug)]
pub enum Amode {
    SpOffset { offset: i64 },
    RegOffset { base: XReg, offset: i64 },
    Stack { amode: StackAMode },
}

/// Internal type ExtKind: defined at src/isa/pulley_shared/inst.isle line 146.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ExtKind {
    None,
    Sign,
    Zero,
}

// Generated as internal constructor for term ty_shift_mask.
pub fn constructor_ty_shift_mask<C: Context>(ctx: &mut C, arg0: Type) -> u64 {
    let v1 = C::lane_type(ctx, arg0);
    let v2 = C::ty_bits(ctx, v1);
    let v3 = C::u8_as_u64(ctx, v2);
    let v5 = C::u64_sub(ctx, v3, 0x1_u64);
    // Rule at src/prelude.isle line 461.
    return v5;
}

// Generated as internal constructor for term output_reg.
pub fn constructor_output_reg<C: Context>(ctx: &mut C, arg0: Reg) -> InstOutput {
    let v1 = C::value_reg(ctx, arg0);
    let v2 = C::output(ctx, v1);
    // Rule at src/prelude_lower.isle line 85.
    return v2;
}

// Generated as internal constructor for term output_value.
pub fn constructor_output_value<C: Context>(ctx: &mut C, arg0: Value) -> InstOutput {
    let v1 = C::put_in_regs(ctx, arg0);
    let v2 = C::output(ctx, v1);
    // Rule at src/prelude_lower.isle line 89.
    return v2;
}

// Generated as internal constructor for term temp_reg.
pub fn constructor_temp_reg<C: Context>(ctx: &mut C, arg0: Type) -> Reg {
    let v1 = C::temp_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src/prelude_lower.isle line 109.
    return v2;
}

// Generated as internal constructor for term value_regs_range.
pub fn constructor_value_regs_range<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Range {
    let v2 = C::value_regs_len(ctx, arg0);
    let v3 = C::range(ctx, 0x0_usize, v2);
    // Rule at src/prelude_lower.isle line 163.
    return v3;
}

// Generated as internal constructor for term lo_reg.
pub fn constructor_lo_reg<C: Context>(ctx: &mut C, arg0: Value) -> Reg {
    let v1 = C::put_in_regs(ctx, arg0);
    let v3 = C::value_regs_get(ctx, v1, 0x0_usize);
    // Rule at src/prelude_lower.isle line 174.
    return v3;
}

// Generated as internal constructor for term multi_reg_to_pair_and_single.
pub fn constructor_multi_reg_to_pair_and_single<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::Three {
        a: v1,
        b: v2,
        c: v3,
    } = arg0
    {
        let v4 = C::value_regs(ctx, v1, v2);
        let v5 = C::value_reg(ctx, v3);
        let v6 = C::output_pair(ctx, v4, v5);
        // Rule at src/prelude_lower.isle line 185.
        return v6;
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "multi_reg_to_pair_and_single", "src/prelude_lower.isle line 184"
    )
}

// Generated as internal constructor for term multi_reg_to_pair.
pub fn constructor_multi_reg_to_pair<C: Context>(ctx: &mut C, arg0: &MultiReg) -> InstOutput {
    if let &MultiReg::Two { a: v1, b: v2 } = arg0 {
        let v3 = C::value_regs(ctx, v1, v2);
        let v4 = C::output(ctx, v3);
        // Rule at src/prelude_lower.isle line 190.
        return v4;
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "multi_reg_to_pair", "src/prelude_lower.isle line 189"
    )
}

// Generated as internal constructor for term multi_reg_to_single.
pub fn constructor_multi_reg_to_single<C: Context>(ctx: &mut C, arg0: &MultiReg) -> InstOutput {
    if let &MultiReg::One { a: v1 } = arg0 {
        let v2 = C::value_reg(ctx, v1);
        let v3 = C::output(ctx, v2);
        // Rule at src/prelude_lower.isle line 195.
        return v3;
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "multi_reg_to_single", "src/prelude_lower.isle line 194"
    )
}

// Generated as internal constructor for term emit_side_effect.
pub fn constructor_emit_side_effect<C: Context>(ctx: &mut C, arg0: &SideEffectNoResult) -> Unit {
    match arg0 {
        &SideEffectNoResult::Inst { inst: ref v1 } => {
            let v2 = C::emit(ctx, v1);
            // Rule at src/prelude_lower.isle line 400.
            return v2;
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref v3,
            inst2: ref v4,
        } => {
            let v5 = C::emit(ctx, v3);
            let v6 = C::emit(ctx, v4);
            // Rule at src/prelude_lower.isle line 402.
            return v6;
        }
        &SideEffectNoResult::Inst3 {
            inst1: ref v7,
            inst2: ref v8,
            inst3: ref v9,
        } => {
            let v10 = C::emit(ctx, v7);
            let v11 = C::emit(ctx, v8);
            let v12 = C::emit(ctx, v9);
            // Rule at src/prelude_lower.isle line 405.
            return v12;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "emit_side_effect", "src/prelude_lower.isle line 399"
    )
}

// Generated as internal constructor for term side_effect.
pub fn constructor_side_effect<C: Context>(ctx: &mut C, arg0: &SideEffectNoResult) -> InstOutput {
    let v1 = constructor_emit_side_effect(ctx, arg0);
    let v2 = C::output_none(ctx);
    // Rule at src/prelude_lower.isle line 415.
    return v2;
}

// Generated as internal constructor for term side_effect_concat.
pub fn constructor_side_effect_concat<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
    arg1: &SideEffectNoResult,
) -> SideEffectNoResult {
    match arg0 {
        &SideEffectNoResult::Inst { inst: ref v1 } => {
            match arg1 {
                &SideEffectNoResult::Inst { inst: ref v3 } => {
                    let v4 = SideEffectNoResult::Inst2 {
                        inst1: v1.clone(),
                        inst2: v3.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 420.
                    return v4;
                }
                &SideEffectNoResult::Inst2 {
                    inst1: ref v5,
                    inst2: ref v6,
                } => {
                    let v7 = SideEffectNoResult::Inst3 {
                        inst1: v1.clone(),
                        inst2: v5.clone(),
                        inst3: v6.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 422.
                    return v7;
                }
                _ => {}
            }
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref v8,
            inst2: ref v9,
        } => {
            if let &SideEffectNoResult::Inst { inst: ref v3 } = arg1 {
                let v10 = SideEffectNoResult::Inst3 {
                    inst1: v8.clone(),
                    inst2: v9.clone(),
                    inst3: v3.clone(),
                };
                // Rule at src/prelude_lower.isle line 424.
                return v10;
            }
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "side_effect_concat", "src/prelude_lower.isle line 419"
    )
}

// Generated as internal constructor for term produces_flags_concat.
pub fn constructor_produces_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ProducesFlags,
) -> ProducesFlags {
    if let &ProducesFlags::ProducesFlagsSideEffect { inst: ref v1 } = arg0 {
        if let &ProducesFlags::ProducesFlagsSideEffect { inst: ref v3 } = arg1 {
            let v4 = ProducesFlags::ProducesFlagsTwiceSideEffect {
                inst1: v1.clone(),
                inst2: v3.clone(),
            };
            // Rule at src/prelude_lower.isle line 449.
            return v4;
        }
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "produces_flags_concat", "src/prelude_lower.isle line 448"
    )
}

// Generated as internal constructor for term produces_flags_get_reg.
pub fn constructor_produces_flags_get_reg<C: Context>(ctx: &mut C, arg0: &ProducesFlags) -> Reg {
    match arg0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            // Rule at src/prelude_lower.isle line 479.
            return v2;
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v3,
            result: v4,
        } => {
            // Rule at src/prelude_lower.isle line 480.
            return v4;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "produces_flags_get_reg", "src/prelude_lower.isle line 478"
    )
}

// Generated as internal constructor for term produces_flags_ignore.
pub fn constructor_produces_flags_ignore<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> ProducesFlags {
    match arg0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            let v3 = ProducesFlags::ProducesFlagsSideEffect { inst: v1.clone() };
            // Rule at src/prelude_lower.isle line 485.
            return v3;
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v4,
            result: v5,
        } => {
            let v6 = ProducesFlags::ProducesFlagsSideEffect { inst: v4.clone() };
            // Rule at src/prelude_lower.isle line 487.
            return v6;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "produces_flags_ignore", "src/prelude_lower.isle line 484"
    )
}

// Generated as internal constructor for term consumes_flags_concat.
pub fn constructor_consumes_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
    arg1: &ConsumesFlags,
) -> ConsumesFlags {
    match arg0 {
        &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v8 } => {
            if let &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v9 } = arg1 {
                let v10 = ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: v8.clone(),
                    inst2: v9.clone(),
                };
                // Rule at src/prelude_lower.isle line 500.
                return v10;
            }
        }
        &ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            if let &ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: ref v4,
                result: v5,
            } = arg1
            {
                let v6 = C::value_regs(ctx, v2, v5);
                let v7 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: v1.clone(),
                    inst2: v4.clone(),
                    result: v6,
                };
                // Rule at src/prelude_lower.isle line 494.
                return v7;
            }
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "consumes_flags_concat", "src/prelude_lower.isle line 493"
    )
}

// Generated as internal constructor for term with_flags.
pub fn constructor_with_flags<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> ValueRegs {
    match arg0 {
        &ProducesFlags::ProducesFlagsSideEffect { inst: ref v12 } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref v13,
                    result: v14,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v16 = C::emit(ctx, v13);
                    let v17 = C::value_reg(ctx, v14);
                    // Rule at src/prelude_lower.isle line 531.
                    return v17;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref v18,
                    inst2: ref v19,
                    result: v20,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v21 = C::emit(ctx, v18);
                    let v22 = C::emit(ctx, v19);
                    // Rule at src/prelude_lower.isle line 537.
                    return v20;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref v23,
                    inst2: ref v24,
                    inst3: ref v25,
                    inst4: ref v26,
                    result: v27,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v28 = C::emit(ctx, v23);
                    let v29 = C::emit(ctx, v24);
                    let v30 = C::emit(ctx, v25);
                    let v31 = C::emit(ctx, v26);
                    // Rule at src/prelude_lower.isle line 549.
                    return v27;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref v32,
            inst2: ref v33,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref v13,
                    result: v14,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v36 = C::emit(ctx, v13);
                    let v37 = C::value_reg(ctx, v14);
                    // Rule at src/prelude_lower.isle line 565.
                    return v37;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref v18,
                    inst2: ref v19,
                    result: v20,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v38 = C::emit(ctx, v18);
                    let v39 = C::emit(ctx, v19);
                    // Rule at src/prelude_lower.isle line 572.
                    return v20;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref v23,
                    inst2: ref v24,
                    inst3: ref v25,
                    inst4: ref v26,
                    result: v27,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v40 = C::emit(ctx, v23);
                    let v41 = C::emit(ctx, v24);
                    let v42 = C::emit(ctx, v25);
                    let v43 = C::emit(ctx, v26);
                    // Rule at src/prelude_lower.isle line 585.
                    return v27;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v1,
            result: v2,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v9 } => {
                    let v6 = C::emit(ctx, v1);
                    let v10 = C::emit(ctx, v9);
                    let v11 = C::value_reg(ctx, v2);
                    // Rule at src/prelude_lower.isle line 525.
                    return v11;
                }
                &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                    inst: ref v4,
                    result: v5,
                } => {
                    let v6 = C::emit(ctx, v1);
                    let v7 = C::emit(ctx, v4);
                    let v8 = C::value_regs(ctx, v2, v5);
                    // Rule at src/prelude_lower.isle line 517.
                    return v8;
                }
                _ => {}
            }
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "with_flags", "src/prelude_lower.isle line 515"
    )
}

// Generated as internal constructor for term with_flags_reg.
pub fn constructor_with_flags_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Reg {
    let v2 = constructor_with_flags(ctx, arg0, arg1);
    let v4 = C::value_regs_get(ctx, v2, 0x0_usize);
    // Rule at src/prelude_lower.isle line 603.
    return v4;
}

// Generated as internal constructor for term flags_to_producesflags.
pub fn constructor_flags_to_producesflags<C: Context>(ctx: &mut C, arg0: Value) -> ProducesFlags {
    let v1 = C::mark_value_used(ctx, arg0);
    // Rule at src/prelude_lower.isle line 610.
    return ProducesFlags::AlreadyExistingFlags;
}

// Generated as internal constructor for term with_flags_side_effect.
pub fn constructor_with_flags_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> SideEffectNoResult {
    match arg0 {
        &ProducesFlags::AlreadyExistingFlags => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v2 } => {
                    let v3 = SideEffectNoResult::Inst { inst: v2.clone() };
                    // Rule at src/prelude_lower.isle line 621.
                    return v3;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref v4,
                    inst2: ref v5,
                } => {
                    let v6 = SideEffectNoResult::Inst2 {
                        inst1: v4.clone(),
                        inst2: v5.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 626.
                    return v6;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsSideEffect { inst: ref v7 } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v2 } => {
                    let v8 = SideEffectNoResult::Inst2 {
                        inst1: v7.clone(),
                        inst2: v2.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 631.
                    return v8;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref v4,
                    inst2: ref v5,
                } => {
                    let v9 = SideEffectNoResult::Inst3 {
                        inst1: v7.clone(),
                        inst2: v4.clone(),
                        inst3: v5.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 636.
                    return v9;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref v10,
            inst2: ref v11,
        } => {
            if let &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v2 } = arg1 {
                let v12 = SideEffectNoResult::Inst3 {
                    inst1: v10.clone(),
                    inst2: v11.clone(),
                    inst3: v2.clone(),
                };
                // Rule at src/prelude_lower.isle line 641.
                return v12;
            }
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "with_flags_side_effect", "src/prelude_lower.isle line 619"
    )
}

// Generated as internal constructor for term with_flags_chained.
pub fn constructor_with_flags_chained<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesAndProducesFlags,
    arg2: &ConsumesFlags,
) -> MultiReg {
    match arg0 {
        &ProducesFlags::ProducesFlagsSideEffect { inst: ref v1 } => {
            match arg1 {
                &ConsumesAndProducesFlags::SideEffect { inst: ref v3 } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v5 } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v8 = C::emit(ctx, v5);
                            // Rule at src/prelude_lower.isle line 650.
                            return MultiReg::Empty;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            // Rule at src/prelude_lower.isle line 658.
                            return MultiReg::Empty;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v16 = C::emit(ctx, v14);
                            let v17 = MultiReg::One { a: v15 };
                            // Rule at src/prelude_lower.isle line 667.
                            return v17;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v27 = MultiReg::Two { a: v24, b: v26 };
                            // Rule at src/prelude_lower.isle line 675.
                            return v27;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v39 = MultiReg::Two { a: v37, b: v38 };
                            // Rule at src/prelude_lower.isle line 684.
                            return v39;
                        }
                        _ => {}
                    }
                }
                &ConsumesAndProducesFlags::ReturnsReg {
                    inst: ref v47,
                    result: v48,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v5 } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v8 = C::emit(ctx, v5);
                            let v50 = MultiReg::One { a: v48 };
                            // Rule at src/prelude_lower.isle line 744.
                            return v50;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v50 = MultiReg::One { a: v48 };
                            // Rule at src/prelude_lower.isle line 752.
                            return v50;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v16 = C::emit(ctx, v14);
                            let v51 = MultiReg::Two { a: v48, b: v15 };
                            // Rule at src/prelude_lower.isle line 761.
                            return v51;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v52 = MultiReg::Three {
                                a: v48,
                                b: v24,
                                c: v26,
                            };
                            // Rule at src/prelude_lower.isle line 769.
                            return v52;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v53 = MultiReg::Three {
                                a: v48,
                                b: v37,
                                c: v38,
                            };
                            // Rule at src/prelude_lower.isle line 778.
                            return v53;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v40,
            result: v41,
        } => {
            match arg1 {
                &ConsumesAndProducesFlags::SideEffect { inst: ref v3 } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v5 } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v8 = C::emit(ctx, v5);
                            let v43 = MultiReg::One { a: v41 };
                            // Rule at src/prelude_lower.isle line 697.
                            return v43;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v43 = MultiReg::One { a: v41 };
                            // Rule at src/prelude_lower.isle line 705.
                            return v43;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v16 = C::emit(ctx, v14);
                            let v44 = MultiReg::Two { a: v41, b: v15 };
                            // Rule at src/prelude_lower.isle line 714.
                            return v44;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v45 = MultiReg::Three {
                                a: v41,
                                b: v24,
                                c: v26,
                            };
                            // Rule at src/prelude_lower.isle line 722.
                            return v45;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v46 = MultiReg::Three {
                                a: v41,
                                b: v37,
                                c: v38,
                            };
                            // Rule at src/prelude_lower.isle line 731.
                            return v46;
                        }
                        _ => {}
                    }
                }
                &ConsumesAndProducesFlags::ReturnsReg {
                    inst: ref v47,
                    result: v48,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v5 } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v8 = C::emit(ctx, v5);
                            let v54 = MultiReg::Two { a: v41, b: v48 };
                            // Rule at src/prelude_lower.isle line 791.
                            return v54;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v54 = MultiReg::Two { a: v41, b: v48 };
                            // Rule at src/prelude_lower.isle line 799.
                            return v54;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v16 = C::emit(ctx, v14);
                            let v55 = MultiReg::Three {
                                a: v41,
                                b: v48,
                                c: v15,
                            };
                            // Rule at src/prelude_lower.isle line 808.
                            return v55;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v56 = MultiReg::Four {
                                a: v41,
                                b: v48,
                                c: v24,
                                d: v26,
                            };
                            // Rule at src/prelude_lower.isle line 816.
                            return v56;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v57 = MultiReg::Four {
                                a: v41,
                                b: v48,
                                c: v37,
                                d: v38,
                            };
                            // Rule at src/prelude_lower.isle line 825.
                            return v57;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v58,
            result: v59,
        } => {
            if let &ConsumesAndProducesFlags::ReturnsReg {
                inst: ref v47,
                result: v48,
            } = arg1
            {
                match arg2 {
                    &ConsumesFlags::ConsumesFlagsSideEffect { inst: ref v5 } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v8 = C::emit(ctx, v5);
                        let v61 = MultiReg::Two { a: v59, b: v48 };
                        // Rule at src/prelude_lower.isle line 837.
                        return v61;
                    }
                    &ConsumesFlags::ConsumesFlagsSideEffect2 {
                        inst1: ref v10,
                        inst2: ref v11,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v12 = C::emit(ctx, v10);
                        let v13 = C::emit(ctx, v11);
                        let v61 = MultiReg::Two { a: v59, b: v48 };
                        // Rule at src/prelude_lower.isle line 845.
                        return v61;
                    }
                    &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                        inst: ref v63,
                        result: v64,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v65 = C::emit(ctx, v63);
                        let v66 = MultiReg::Three {
                            a: v59,
                            b: v48,
                            c: v64,
                        };
                        // Rule at src/prelude_lower.isle line 862.
                        return v66;
                    }
                    &ConsumesFlags::ConsumesFlagsReturnsReg {
                        inst: ref v14,
                        result: v15,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v16 = C::emit(ctx, v14);
                        let v62 = MultiReg::Three {
                            a: v59,
                            b: v48,
                            c: v15,
                        };
                        // Rule at src/prelude_lower.isle line 854.
                        return v62;
                    }
                    &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                        inst1: ref v18,
                        inst2: ref v19,
                        result: v20,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v21 = C::emit(ctx, v18);
                        let v22 = C::emit(ctx, v19);
                        let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                        let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                        let v67 = MultiReg::Four {
                            a: v59,
                            b: v48,
                            c: v24,
                            d: v26,
                        };
                        // Rule at src/prelude_lower.isle line 870.
                        return v67;
                    }
                    &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                        inst1: ref v28,
                        inst2: ref v29,
                        inst3: ref v30,
                        inst4: ref v31,
                        result: v32,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v33 = C::emit(ctx, v28);
                        let v34 = C::emit(ctx, v29);
                        let v35 = C::emit(ctx, v30);
                        let v36 = C::emit(ctx, v31);
                        let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                        let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                        let v68 = MultiReg::Four {
                            a: v59,
                            b: v48,
                            c: v37,
                            d: v38,
                        };
                        // Rule at src/prelude_lower.isle line 879.
                        return v68;
                    }
                    _ => {}
                }
            }
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "with_flags_chained", "src/prelude_lower.isle line 647"
    )
}

// Generated as internal constructor for term lower_return.
pub fn constructor_lower_return<C: Context>(ctx: &mut C, arg0: ValueSlice) -> InstOutput {
    let v1 = C::gen_return(ctx, arg0);
    let v2 = C::output_none(ctx);
    // Rule at src/prelude_lower.isle line 1082.
    return v2;
}

// Generated as internal constructor for term ty_to_operand_size.
pub fn constructor_ty_to_operand_size<C: Context>(ctx: &mut C, arg0: Type) -> OperandSize {
    match arg0 {
        I32 => {
            // Rule at src/isa/pulley_shared/inst.isle line 5.
            return OperandSize::Size32;
        }
        I64 => {
            // Rule at src/isa/pulley_shared/inst.isle line 6.
            return OperandSize::Size64;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "ty_to_operand_size", "src/isa/pulley_shared/inst.isle line 4"
    )
}

// Generated as internal constructor for term put_in_xreg.
pub fn constructor_put_in_xreg<C: Context>(ctx: &mut C, arg0: Value) -> XReg {
    let v1 = C::put_in_reg(ctx, arg0);
    let v2 = C::xreg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 177.
    return v2;
}

// Generated as internal constructor for term output_xreg.
pub fn constructor_output_xreg<C: Context>(ctx: &mut C, arg0: XReg) -> InstOutput {
    let v1 = C::xreg_to_reg(ctx, arg0);
    let v2 = constructor_output_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 182.
    return v2;
}

// Generated as internal constructor for term writable_xreg_to_reg.
pub fn constructor_writable_xreg_to_reg<C: Context>(ctx: &mut C, arg0: WritableXReg) -> Reg {
    let v1 = C::writable_xreg_to_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 197.
    return v2;
}

// Generated as internal constructor for term xreg_to_value_regs.
pub fn constructor_xreg_to_value_regs<C: Context>(ctx: &mut C, arg0: XReg) -> ValueRegs {
    let v1 = C::xreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 207.
    return v2;
}

// Generated as internal constructor for term writable_xreg_to_value_regs.
pub fn constructor_writable_xreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableXReg,
) -> ValueRegs {
    let v1 = constructor_writable_xreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 212.
    return v2;
}

// Generated as internal constructor for term temp_writable_xreg.
pub fn constructor_temp_writable_xreg<C: Context>(ctx: &mut C) -> WritableXReg {
    let v1 = C::temp_writable_reg(ctx, I64);
    let v2 = C::writable_xreg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 217.
    return v2;
}

// Generated as internal constructor for term put_in_freg.
pub fn constructor_put_in_freg<C: Context>(ctx: &mut C, arg0: Value) -> FReg {
    let v1 = C::put_in_reg(ctx, arg0);
    let v2 = C::freg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 237.
    return v2;
}

// Generated as internal constructor for term output_freg.
pub fn constructor_output_freg<C: Context>(ctx: &mut C, arg0: FReg) -> InstOutput {
    let v1 = C::freg_to_reg(ctx, arg0);
    let v2 = constructor_output_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 242.
    return v2;
}

// Generated as internal constructor for term writable_freg_to_reg.
pub fn constructor_writable_freg_to_reg<C: Context>(ctx: &mut C, arg0: WritableFReg) -> Reg {
    let v1 = C::writable_freg_to_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 257.
    return v2;
}

// Generated as internal constructor for term freg_to_value_regs.
pub fn constructor_freg_to_value_regs<C: Context>(ctx: &mut C, arg0: FReg) -> ValueRegs {
    let v1 = C::freg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 267.
    return v2;
}

// Generated as internal constructor for term writable_freg_to_value_regs.
pub fn constructor_writable_freg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableFReg,
) -> ValueRegs {
    let v1 = constructor_writable_freg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 272.
    return v2;
}

// Generated as internal constructor for term temp_writable_freg.
pub fn constructor_temp_writable_freg<C: Context>(ctx: &mut C) -> WritableFReg {
    let v1 = C::temp_writable_reg(ctx, F64);
    let v2 = C::writable_freg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 277.
    return v2;
}

// Generated as internal constructor for term put_in_vreg.
pub fn constructor_put_in_vreg<C: Context>(ctx: &mut C, arg0: Value) -> VReg {
    let v1 = C::put_in_reg(ctx, arg0);
    let v2 = C::vreg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 297.
    return v2;
}

// Generated as internal constructor for term output_vreg.
pub fn constructor_output_vreg<C: Context>(ctx: &mut C, arg0: VReg) -> InstOutput {
    let v1 = C::vreg_to_reg(ctx, arg0);
    let v2 = constructor_output_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 302.
    return v2;
}

// Generated as internal constructor for term writable_vreg_to_reg.
pub fn constructor_writable_vreg_to_reg<C: Context>(ctx: &mut C, arg0: WritableVReg) -> Reg {
    let v1 = C::writable_vreg_to_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 317.
    return v2;
}

// Generated as internal constructor for term vreg_to_value_regs.
pub fn constructor_vreg_to_value_regs<C: Context>(ctx: &mut C, arg0: VReg) -> ValueRegs {
    let v1 = C::vreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 327.
    return v2;
}

// Generated as internal constructor for term writable_vreg_to_value_regs.
pub fn constructor_writable_vreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableVReg,
) -> ValueRegs {
    let v1 = constructor_writable_vreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 332.
    return v2;
}

// Generated as internal constructor for term temp_writable_vreg.
pub fn constructor_temp_writable_vreg<C: Context>(ctx: &mut C) -> WritableVReg {
    let v1 = C::temp_writable_reg(ctx, I8X16);
    let v2 = C::writable_vreg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 337.
    return v2;
}

// Generated as internal constructor for term imm.
pub fn constructor_imm<C: Context>(ctx: &mut C, arg0: Type, arg1: u64) -> Reg {
    let v1 = C::ty_int(ctx, arg0);
    if let Some(v2) = v1 {
        let v4 = C::i8_try_from_u64(ctx, arg1);
        if let Some(v5) = v4 {
            let v6 = constructor_pulley_xconst8(ctx, v5);
            let v7 = C::xreg_to_reg(ctx, v6);
            // Rule at src/isa/pulley_shared/inst.isle line 345.
            return v7;
        }
        let v8 = C::i16_try_from_u64(ctx, arg1);
        if let Some(v9) = v8 {
            let v10 = constructor_pulley_xconst16(ctx, v9);
            let v11 = C::xreg_to_reg(ctx, v10);
            // Rule at src/isa/pulley_shared/inst.isle line 350.
            return v11;
        }
        let v12 = C::i32_try_from_u64(ctx, arg1);
        if let Some(v13) = v12 {
            let v14 = constructor_pulley_xconst32(ctx, v13);
            let v15 = C::xreg_to_reg(ctx, v14);
            // Rule at src/isa/pulley_shared/inst.isle line 355.
            return v15;
        }
    }
    match arg0 {
        I8 => {
            let v16 = C::u64_as_u8(ctx, arg1);
            let v17 = C::u8_as_i8(ctx, v16);
            let v18 = constructor_pulley_xconst8(ctx, v17);
            let v19 = C::xreg_to_reg(ctx, v18);
            // Rule at src/isa/pulley_shared/inst.isle line 360.
            return v19;
        }
        I16 => {
            let v20 = C::u64_as_u16(ctx, arg1);
            let v21 = C::u16_as_i16(ctx, v20);
            let v22 = constructor_pulley_xconst16(ctx, v21);
            let v23 = C::xreg_to_reg(ctx, v22);
            // Rule at src/isa/pulley_shared/inst.isle line 361.
            return v23;
        }
        I32 => {
            let v24 = C::u64_as_i32(ctx, arg1);
            let v25 = constructor_pulley_xconst32(ctx, v24);
            let v26 = C::xreg_to_reg(ctx, v25);
            // Rule at src/isa/pulley_shared/inst.isle line 362.
            return v26;
        }
        I64 => {
            let v27 = C::u64_as_i64(ctx, arg1);
            let v28 = constructor_pulley_xconst64(ctx, v27);
            let v29 = C::xreg_to_reg(ctx, v28);
            // Rule at src/isa/pulley_shared/inst.isle line 363.
            return v29;
        }
        F32 => {
            let v31 = constructor_imm(ctx, I32, arg1);
            let v33 = constructor_gen_bitcast(ctx, v31, I32, F32);
            // Rule at src/isa/pulley_shared/inst.isle line 366.
            return v33;
        }
        F64 => {
            let v35 = constructor_imm(ctx, I64, arg1);
            let v37 = constructor_gen_bitcast(ctx, v35, I64, F64);
            // Rule at src/isa/pulley_shared/inst.isle line 367.
            return v37;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "imm", "src/isa/pulley_shared/inst.isle line 342"
    )
}

// Generated as internal constructor for term gen_bitcast.
pub fn constructor_gen_bitcast<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type, arg2: Type) -> Reg {
    match arg1 {
        I32 => {
            if arg2 == F32 {
                let v8 = C::freg_new(ctx, arg0);
                let v9 = constructor_pulley_bitcast_int_from_float_32(ctx, v8);
                let v10 = C::xreg_to_reg(ctx, v9);
                // Rule at src/isa/pulley_shared/inst.isle line 375.
                return v10;
            }
        }
        I64 => {
            if arg2 == F64 {
                let v8 = C::freg_new(ctx, arg0);
                let v11 = constructor_pulley_bitcast_int_from_float_64(ctx, v8);
                let v12 = C::xreg_to_reg(ctx, v11);
                // Rule at src/isa/pulley_shared/inst.isle line 376.
                return v12;
            }
        }
        F32 => {
            if arg2 == I32 {
                let v3 = C::xreg_new(ctx, arg0);
                let v4 = constructor_pulley_bitcast_float_from_int_32(ctx, v3);
                let v5 = C::freg_to_reg(ctx, v4);
                // Rule at src/isa/pulley_shared/inst.isle line 373.
                return v5;
            }
        }
        F64 => {
            if arg2 == I64 {
                let v3 = C::xreg_new(ctx, arg0);
                let v6 = constructor_pulley_bitcast_float_from_int_64(ctx, v3);
                let v7 = C::freg_to_reg(ctx, v6);
                // Rule at src/isa/pulley_shared/inst.isle line 374.
                return v7;
            }
        }
        _ => {}
    }
    if arg1 == arg2 {
        // Rule at src/isa/pulley_shared/inst.isle line 377.
        return arg0;
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "gen_bitcast", "src/isa/pulley_shared/inst.isle line 372"
    )
}

// Generated as internal constructor for term pulley_trap.
pub fn constructor_pulley_trap<C: Context>(ctx: &mut C, arg0: &TrapCode) -> SideEffectNoResult {
    let v1 = MInst::Trap { code: arg0.clone() };
    let v2 = SideEffectNoResult::Inst { inst: v1 };
    // Rule at src/isa/pulley_shared/inst.isle line 382.
    return v2;
}

// Generated as internal constructor for term pulley_trap_if.
pub fn constructor_pulley_trap_if<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: &OperandSize,
    arg2: XReg,
    arg3: XReg,
    arg4: &TrapCode,
) -> SideEffectNoResult {
    let v5 = MInst::TrapIf {
        cond: arg0.clone(),
        size: arg1.clone(),
        src1: arg2,
        src2: arg3,
        code: arg4.clone(),
    };
    let v6 = SideEffectNoResult::Inst { inst: v5 };
    // Rule at src/isa/pulley_shared/inst.isle line 386.
    return v6;
}

// Generated as internal constructor for term pulley_get_special.
pub fn constructor_pulley_get_special<C: Context>(ctx: &mut C, arg0: XReg) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = MInst::GetSpecial { dst: v1, reg: arg0 };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 399.
    return v4;
}

// Generated as internal constructor for term pulley_xconst8.
pub fn constructor_pulley_xconst8<C: Context>(ctx: &mut C, arg0: i8) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = MInst::Xconst8 { dst: v1, imm: arg0 };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 405.
    return v4;
}

// Generated as internal constructor for term pulley_xconst16.
pub fn constructor_pulley_xconst16<C: Context>(ctx: &mut C, arg0: i16) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = MInst::Xconst16 { dst: v1, imm: arg0 };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 411.
    return v4;
}

// Generated as internal constructor for term pulley_xconst32.
pub fn constructor_pulley_xconst32<C: Context>(ctx: &mut C, arg0: i32) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = MInst::Xconst32 { dst: v1, imm: arg0 };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 417.
    return v4;
}

// Generated as internal constructor for term pulley_xconst64.
pub fn constructor_pulley_xconst64<C: Context>(ctx: &mut C, arg0: i64) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = MInst::Xconst64 { dst: v1, imm: arg0 };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 423.
    return v4;
}

// Generated as internal constructor for term pulley_jump.
pub fn constructor_pulley_jump<C: Context>(ctx: &mut C, arg0: MachLabel) -> SideEffectNoResult {
    let v1 = MInst::Jump { label: arg0 };
    let v2 = SideEffectNoResult::Inst { inst: v1 };
    // Rule at src/isa/pulley_shared/inst.isle line 429.
    return v2;
}

// Generated as internal constructor for term pulley_br_if.
pub fn constructor_pulley_br_if<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: MachLabel,
    arg2: MachLabel,
) -> SideEffectNoResult {
    let v3 = MInst::BrIf {
        c: arg0,
        taken: arg1,
        not_taken: arg2,
    };
    let v4 = SideEffectNoResult::Inst { inst: v3 };
    // Rule at src/isa/pulley_shared/inst.isle line 433.
    return v4;
}

// Generated as internal constructor for term pulley_br_if_xeq32.
pub fn constructor_pulley_br_if_xeq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: MachLabel,
    arg3: MachLabel,
) -> SideEffectNoResult {
    let v4 = MInst::BrIfXeq32 {
        src1: arg0,
        src2: arg1,
        taken: arg2,
        not_taken: arg3,
    };
    let v5 = SideEffectNoResult::Inst { inst: v4 };
    // Rule at src/isa/pulley_shared/inst.isle line 437.
    return v5;
}

// Generated as internal constructor for term pulley_br_if_xneq32.
pub fn constructor_pulley_br_if_xneq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: MachLabel,
    arg3: MachLabel,
) -> SideEffectNoResult {
    let v4 = MInst::BrIfXneq32 {
        src1: arg0,
        src2: arg1,
        taken: arg2,
        not_taken: arg3,
    };
    let v5 = SideEffectNoResult::Inst { inst: v4 };
    // Rule at src/isa/pulley_shared/inst.isle line 441.
    return v5;
}

// Generated as internal constructor for term pulley_br_if_xslt32.
pub fn constructor_pulley_br_if_xslt32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: MachLabel,
    arg3: MachLabel,
) -> SideEffectNoResult {
    let v4 = MInst::BrIfXslt32 {
        src1: arg0,
        src2: arg1,
        taken: arg2,
        not_taken: arg3,
    };
    let v5 = SideEffectNoResult::Inst { inst: v4 };
    // Rule at src/isa/pulley_shared/inst.isle line 445.
    return v5;
}

// Generated as internal constructor for term pulley_br_if_xslteq32.
pub fn constructor_pulley_br_if_xslteq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: MachLabel,
    arg3: MachLabel,
) -> SideEffectNoResult {
    let v4 = MInst::BrIfXslteq32 {
        src1: arg0,
        src2: arg1,
        taken: arg2,
        not_taken: arg3,
    };
    let v5 = SideEffectNoResult::Inst { inst: v4 };
    // Rule at src/isa/pulley_shared/inst.isle line 449.
    return v5;
}

// Generated as internal constructor for term pulley_br_if_xult32.
pub fn constructor_pulley_br_if_xult32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: MachLabel,
    arg3: MachLabel,
) -> SideEffectNoResult {
    let v4 = MInst::BrIfXult32 {
        src1: arg0,
        src2: arg1,
        taken: arg2,
        not_taken: arg3,
    };
    let v5 = SideEffectNoResult::Inst { inst: v4 };
    // Rule at src/isa/pulley_shared/inst.isle line 453.
    return v5;
}

// Generated as internal constructor for term pulley_br_if_xulteq32.
pub fn constructor_pulley_br_if_xulteq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: MachLabel,
    arg3: MachLabel,
) -> SideEffectNoResult {
    let v4 = MInst::BrIfXulteq32 {
        src1: arg0,
        src2: arg1,
        taken: arg2,
        not_taken: arg3,
    };
    let v5 = SideEffectNoResult::Inst { inst: v4 };
    // Rule at src/isa/pulley_shared/inst.isle line 457.
    return v5;
}

// Generated as internal constructor for term pulley_xadd32.
pub fn constructor_pulley_xadd32<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xadd32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 461.
    return v5;
}

// Generated as internal constructor for term pulley_xadd64.
pub fn constructor_pulley_xadd64<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xadd64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 467.
    return v5;
}

// Generated as internal constructor for term pulley_xeq64.
pub fn constructor_pulley_xeq64<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xeq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 473.
    return v5;
}

// Generated as internal constructor for term pulley_xneq64.
pub fn constructor_pulley_xneq64<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xneq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 479.
    return v5;
}

// Generated as internal constructor for term pulley_xslt64.
pub fn constructor_pulley_xslt64<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xslt64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 485.
    return v5;
}

// Generated as internal constructor for term pulley_xslteq64.
pub fn constructor_pulley_xslteq64<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xslteq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 491.
    return v5;
}

// Generated as internal constructor for term pulley_xult64.
pub fn constructor_pulley_xult64<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xult64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 497.
    return v5;
}

// Generated as internal constructor for term pulley_xulteq64.
pub fn constructor_pulley_xulteq64<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xulteq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 503.
    return v5;
}

// Generated as internal constructor for term pulley_xeq32.
pub fn constructor_pulley_xeq32<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xeq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 509.
    return v5;
}

// Generated as internal constructor for term pulley_xneq32.
pub fn constructor_pulley_xneq32<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xneq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 515.
    return v5;
}

// Generated as internal constructor for term pulley_xslt32.
pub fn constructor_pulley_xslt32<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xslt32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 521.
    return v5;
}

// Generated as internal constructor for term pulley_xslteq32.
pub fn constructor_pulley_xslteq32<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xslteq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 527.
    return v5;
}

// Generated as internal constructor for term pulley_xult32.
pub fn constructor_pulley_xult32<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xult32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 533.
    return v5;
}

// Generated as internal constructor for term pulley_xulteq32.
pub fn constructor_pulley_xulteq32<C: Context>(ctx: &mut C, arg0: XReg, arg1: XReg) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::Xulteq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 539.
    return v5;
}

// Generated as internal constructor for term pulley_load.
pub fn constructor_pulley_load<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: Type,
    arg2: MemFlags,
    arg3: &ExtKind,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg1);
    let v5 = MInst::Load {
        dst: v4,
        mem: arg0.clone(),
        ty: arg1,
        flags: arg2,
        ext: arg3.clone(),
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src/isa/pulley_shared/inst.isle line 545.
    return v7;
}

// Generated as internal constructor for term pulley_store.
pub fn constructor_pulley_store<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: Reg,
    arg2: Type,
    arg3: MemFlags,
) -> SideEffectNoResult {
    let v4 = MInst::Store {
        mem: arg0.clone(),
        src: arg1,
        ty: arg2,
        flags: arg3,
    };
    let v5 = SideEffectNoResult::Inst { inst: v4 };
    // Rule at src/isa/pulley_shared/inst.isle line 551.
    return v5;
}

// Generated as internal constructor for term pulley_bitcast_float_from_int_32.
pub fn constructor_pulley_bitcast_float_from_int_32<C: Context>(ctx: &mut C, arg0: XReg) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = MInst::BitcastFloatFromInt32 { dst: v1, src: arg0 };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_freg_to_freg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 555.
    return v4;
}

// Generated as internal constructor for term pulley_bitcast_float_from_int_64.
pub fn constructor_pulley_bitcast_float_from_int_64<C: Context>(ctx: &mut C, arg0: XReg) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = MInst::BitcastFloatFromInt64 { dst: v1, src: arg0 };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_freg_to_freg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 561.
    return v4;
}

// Generated as internal constructor for term pulley_bitcast_int_from_float_32.
pub fn constructor_pulley_bitcast_int_from_float_32<C: Context>(ctx: &mut C, arg0: FReg) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = MInst::BitcastIntFromFloat32 { dst: v1, src: arg0 };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 567.
    return v4;
}

// Generated as internal constructor for term pulley_bitcast_int_from_float_64.
pub fn constructor_pulley_bitcast_int_from_float_64<C: Context>(ctx: &mut C, arg0: FReg) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = MInst::BitcastIntFromFloat64 { dst: v1, src: arg0 };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 573.
    return v4;
}

// Generated as internal constructor for term gen_br_table.
pub fn constructor_gen_br_table<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: MachLabel,
    arg2: &BoxVecMachLabel,
) -> Unit {
    let v3 = MInst::BrTable {
        idx: arg0,
        default: arg1,
        targets: arg2.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    // Rule at src/isa/pulley_shared/inst.isle line 579.
    return v4;
}

// Generated as internal constructor for term lower.
pub fn constructor_lower<C: Context>(ctx: &mut C, arg0: Inst) -> Option<InstOutput> {
    let v1 = &C::inst_data(ctx, arg0);
    match v1 {
        &InstructionData::Binary {
            opcode: ref v109,
            args: ref v110,
        } => {
            if let &Opcode::Iadd = v109 {
                let v100 = C::first_result(ctx, arg0);
                if let Some(v101) = v100 {
                    let v102 = C::value_type(ctx, v101);
                    match v102 {
                        I8 => {
                            let v111 = C::unpack_value_array_2(ctx, v110);
                            let v114 = constructor_put_in_xreg(ctx, v111.0);
                            let v115 = constructor_put_in_xreg(ctx, v111.1);
                            let v116 = constructor_pulley_xadd32(ctx, v114, v115);
                            let v117 = constructor_output_xreg(ctx, v116);
                            let v118 = Some(v117);
                            // Rule at src/isa/pulley_shared/lower.isle line 157.
                            return v118;
                        }
                        I16 => {
                            let v111 = C::unpack_value_array_2(ctx, v110);
                            let v114 = constructor_put_in_xreg(ctx, v111.0);
                            let v115 = constructor_put_in_xreg(ctx, v111.1);
                            let v116 = constructor_pulley_xadd32(ctx, v114, v115);
                            let v117 = constructor_output_xreg(ctx, v116);
                            let v118 = Some(v117);
                            // Rule at src/isa/pulley_shared/lower.isle line 160.
                            return v118;
                        }
                        I32 => {
                            let v111 = C::unpack_value_array_2(ctx, v110);
                            let v114 = constructor_put_in_xreg(ctx, v111.0);
                            let v115 = constructor_put_in_xreg(ctx, v111.1);
                            let v116 = constructor_pulley_xadd32(ctx, v114, v115);
                            let v117 = constructor_output_xreg(ctx, v116);
                            let v118 = Some(v117);
                            // Rule at src/isa/pulley_shared/lower.isle line 163.
                            return v118;
                        }
                        I64 => {
                            let v111 = C::unpack_value_array_2(ctx, v110);
                            let v114 = constructor_put_in_xreg(ctx, v111.0);
                            let v115 = constructor_put_in_xreg(ctx, v111.1);
                            let v119 = constructor_pulley_xadd64(ctx, v114, v115);
                            let v120 = constructor_output_xreg(ctx, v119);
                            let v121 = Some(v120);
                            // Rule at src/isa/pulley_shared/lower.isle line 166.
                            return v121;
                        }
                        _ => {}
                    }
                }
            }
        }
        &InstructionData::Call {
            opcode: ref v76,
            args: v77,
            func_ref: v78,
        } => {
            match v76 {
                &Opcode::Call => {
                    let v80 = C::func_ref_data(ctx, v78);
                    let v79 = C::value_list_slice(ctx, v77);
                    let v84 = C::gen_call(ctx, v80.0, v80.1, v80.2, v79);
                    let v85 = Some(v84);
                    // Rule at src/isa/pulley_shared/lower.isle line 136.
                    return v85;
                }
                &Opcode::ReturnCall => {
                    let v80 = C::func_ref_data(ctx, v78);
                    let v79 = C::value_list_slice(ctx, v77);
                    let v96 = C::gen_return_call(ctx, v80.0, v80.1, v80.2, v79);
                    let v97 = Some(v96);
                    // Rule at src/isa/pulley_shared/lower.isle line 144.
                    return v97;
                }
                _ => {}
            }
        }
        &InstructionData::CallIndirect {
            opcode: ref v86,
            args: v87,
            sig_ref: v88,
        } => {
            match v86 {
                &Opcode::CallIndirect => {
                    let v89 = C::value_list_slice(ctx, v87);
                    let v90 = C::value_slice_unwrap(ctx, v89);
                    if let Some(v91) = v90 {
                        let v94 = C::gen_call_indirect(ctx, v88, v91.0, v91.1);
                        let v95 = Some(v94);
                        // Rule at src/isa/pulley_shared/lower.isle line 139.
                        return v95;
                    }
                }
                &Opcode::ReturnCallIndirect => {
                    let v89 = C::value_list_slice(ctx, v87);
                    let v90 = C::value_slice_unwrap(ctx, v89);
                    if let Some(v91) = v90 {
                        let v98 = C::gen_return_call_indirect(ctx, v88, v91.0, v91.1);
                        let v99 = Some(v98);
                        // Rule at src/isa/pulley_shared/lower.isle line 147.
                        return v99;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::CondTrap {
            opcode: ref v7,
            arg: v8,
            code: ref v9,
        } => {
            match v7 {
                &Opcode::Trapz => {
                    let v27 = C::def_inst(ctx, v8);
                    if let Some(v28) = v27 {
                        let v29 = &C::inst_data(ctx, v28);
                        match v29 {
                            &InstructionData::IntCompare {
                                opcode: ref v30,
                                args: ref v31,
                                cond: ref v32,
                            } => {
                                if let &Opcode::Icmp = v30 {
                                    let v33 = C::unpack_value_array_2(ctx, v31);
                                    let v36 = C::value_type(ctx, v33.1);
                                    let v37 = C::fits_in_64(ctx, v36);
                                    if let Some(v38) = v37 {
                                        let v39 = &C::intcc_complement(ctx, v32);
                                        let v40 = &constructor_ty_to_operand_size(ctx, v38);
                                        let v41 = constructor_put_in_xreg(ctx, v33.0);
                                        let v42 = constructor_put_in_xreg(ctx, v33.1);
                                        let v43 = &constructor_pulley_trap_if(
                                            ctx, v39, v40, v41, v42, v9,
                                        );
                                        let v44 = constructor_side_effect(ctx, v43);
                                        let v45 = Some(v44);
                                        // Rule at src/isa/pulley_shared/lower.isle line 79.
                                        return v45;
                                    }
                                }
                            }
                            &InstructionData::UnaryImm {
                                opcode: ref v52,
                                imm: v53,
                            } => {
                                if let &Opcode::Iconst = v52 {
                                    let v54 = C::u64_from_imm64(ctx, v53);
                                    let v55 = C::u64_is_zero(ctx, v54);
                                    if v55 == false {
                                        let v56 = C::output_none(ctx);
                                        let v57 = Some(v56);
                                        // Rule at src/isa/pulley_shared/lower.isle line 95.
                                        return v57;
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    let v10 = C::value_type(ctx, v8);
                    let v11 = C::fits_in_64(ctx, v10);
                    if let Some(v12) = v11 {
                        let v14 = constructor_pulley_xconst8(ctx, 0_i8);
                        let v17 = &constructor_ty_to_operand_size(ctx, v12);
                        let v18 = constructor_put_in_xreg(ctx, v8);
                        let v15 = C::xreg_to_reg(ctx, v14);
                        let v19 = C::xreg_new(ctx, v15);
                        let v20 =
                            &constructor_pulley_trap_if(ctx, &IntCC::Equal, v17, v18, v19, v9);
                        let v21 = constructor_side_effect(ctx, v20);
                        let v22 = Some(v21);
                        // Rule at src/isa/pulley_shared/lower.isle line 61.
                        return v22;
                    }
                }
                &Opcode::Trapnz => {
                    let v27 = C::def_inst(ctx, v8);
                    if let Some(v28) = v27 {
                        let v29 = &C::inst_data(ctx, v28);
                        match v29 {
                            &InstructionData::IntCompare {
                                opcode: ref v30,
                                args: ref v31,
                                cond: ref v32,
                            } => {
                                if let &Opcode::Icmp = v30 {
                                    let v33 = C::unpack_value_array_2(ctx, v31);
                                    let v36 = C::value_type(ctx, v33.1);
                                    let v37 = C::fits_in_64(ctx, v36);
                                    if let Some(v38) = v37 {
                                        let v46 = &constructor_ty_to_operand_size(ctx, v38);
                                        let v47 = constructor_put_in_xreg(ctx, v33.0);
                                        let v48 = constructor_put_in_xreg(ctx, v33.1);
                                        let v49 = &constructor_pulley_trap_if(
                                            ctx, v32, v46, v47, v48, v9,
                                        );
                                        let v50 = constructor_side_effect(ctx, v49);
                                        let v51 = Some(v50);
                                        // Rule at src/isa/pulley_shared/lower.isle line 86.
                                        return v51;
                                    }
                                }
                            }
                            &InstructionData::UnaryImm {
                                opcode: ref v52,
                                imm: v53,
                            } => {
                                if let &Opcode::Iconst = v52 {
                                    let v54 = C::u64_from_imm64(ctx, v53);
                                    if v54 == 0x0_u64 {
                                        let v56 = C::output_none(ctx);
                                        let v57 = Some(v56);
                                        // Rule at src/isa/pulley_shared/lower.isle line 98.
                                        return v57;
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    let v10 = C::value_type(ctx, v8);
                    let v11 = C::fits_in_64(ctx, v10);
                    if let Some(v12) = v11 {
                        let v14 = constructor_pulley_xconst8(ctx, 0_i8);
                        let v17 = &constructor_ty_to_operand_size(ctx, v12);
                        let v18 = constructor_put_in_xreg(ctx, v8);
                        let v15 = C::xreg_to_reg(ctx, v14);
                        let v19 = C::xreg_new(ctx, v15);
                        let v24 =
                            &constructor_pulley_trap_if(ctx, &IntCC::NotEqual, v17, v18, v19, v9);
                        let v25 = constructor_side_effect(ctx, v24);
                        let v26 = Some(v25);
                        // Rule at src/isa/pulley_shared/lower.isle line 69.
                        return v26;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::IntCompare {
            opcode: ref v122,
            args: ref v123,
            cond: ref v124,
        } => {
            if let &Opcode::Icmp = v122 {
                let v125 = C::unpack_value_array_2(ctx, v123);
                let v128 = C::value_type(ctx, v125.1);
                if v128 == I64 {
                    let v130 = constructor_lower_icmp(ctx, I64, v124, v125.0, v125.1);
                    let v131 = constructor_output_xreg(ctx, v130);
                    let v132 = Some(v131);
                    // Rule at src/isa/pulley_shared/lower.isle line 171.
                    return v132;
                }
                let v133 = C::fits_in_32(ctx, v128);
                if let Some(v134) = v133 {
                    let v136 = constructor_lower_icmp(ctx, I32, v124, v125.0, v125.1);
                    let v137 = constructor_output_xreg(ctx, v136);
                    let v138 = Some(v137);
                    // Rule at src/isa/pulley_shared/lower.isle line 173.
                    return v138;
                }
            }
        }
        &InstructionData::Load {
            opcode: ref v139,
            arg: v140,
            flags: v141,
            offset: v142,
        } => {
            if let &Opcode::Load = v139 {
                let v100 = C::first_result(ctx, arg0);
                if let Some(v101) = v100 {
                    let v144 = constructor_put_in_xreg(ctx, v140);
                    let v143 = C::offset32(ctx, v142);
                    let v145 = C::i32_as_i64(ctx, v143);
                    let v146 = Amode::RegOffset {
                        base: v144,
                        offset: v145,
                    };
                    let v102 = C::value_type(ctx, v101);
                    let v148 = constructor_pulley_load(ctx, &v146, v102, v141, &ExtKind::Zero);
                    let v149 = constructor_output_reg(ctx, v148);
                    let v150 = Some(v149);
                    // Rule at src/isa/pulley_shared/lower.isle line 227.
                    return v150;
                }
            }
        }
        &InstructionData::MultiAry {
            opcode: ref v71,
            args: v72,
        } => {
            if let &Opcode::Return = v71 {
                let v73 = C::value_list_slice(ctx, v72);
                let v74 = constructor_lower_return(ctx, v73);
                let v75 = Some(v74);
                // Rule at src/isa/pulley_shared/lower.isle line 131.
                return v75;
            }
        }
        &InstructionData::NullAry { opcode: ref v58 } => {
            match v58 {
                &Opcode::GetFramePointer => {
                    let v63 = C::fp_reg(ctx);
                    let v64 = constructor_pulley_get_special(ctx, v63);
                    let v65 = constructor_output_xreg(ctx, v64);
                    let v66 = Some(v65);
                    // Rule at src/isa/pulley_shared/lower.isle line 120.
                    return v66;
                }
                &Opcode::GetStackPointer => {
                    let v59 = C::sp_reg(ctx);
                    let v60 = constructor_pulley_get_special(ctx, v59);
                    let v61 = constructor_output_xreg(ctx, v60);
                    let v62 = Some(v61);
                    // Rule at src/isa/pulley_shared/lower.isle line 115.
                    return v62;
                }
                &Opcode::GetReturnAddress => {
                    let v67 = C::lr_reg(ctx);
                    let v68 = constructor_pulley_get_special(ctx, v67);
                    let v69 = constructor_output_xreg(ctx, v68);
                    let v70 = Some(v69);
                    // Rule at src/isa/pulley_shared/lower.isle line 125.
                    return v70;
                }
                _ => {}
            }
        }
        &InstructionData::StackLoad {
            opcode: ref v167,
            stack_slot: v168,
            offset: v169,
        } => {
            if let &Opcode::StackAddr = v167 {
                let v170 = constructor_lower_stack_addr(ctx, v168, v169);
                let v171 = constructor_output_xreg(ctx, v170);
                let v172 = Some(v171);
                // Rule at src/isa/pulley_shared/lower.isle line 243.
                return v172;
            }
        }
        &InstructionData::Store {
            opcode: ref v151,
            args: ref v152,
            flags: v153,
            offset: v154,
        } => {
            if let &Opcode::Store = v151 {
                let v155 = C::unpack_value_array_2(ctx, v152);
                let v160 = constructor_put_in_xreg(ctx, v155.1);
                let v163 = C::put_in_reg(ctx, v155.0);
                let v159 = C::offset32(ctx, v154);
                let v161 = C::i32_as_i64(ctx, v159);
                let v162 = Amode::RegOffset {
                    base: v160,
                    offset: v161,
                };
                let v158 = C::value_type(ctx, v155.0);
                let v164 = &constructor_pulley_store(ctx, &v162, v163, v158, v153);
                let v165 = constructor_side_effect(ctx, v164);
                let v166 = Some(v165);
                // Rule at src/isa/pulley_shared/lower.isle line 235.
                return v166;
            }
        }
        &InstructionData::Trap {
            opcode: ref v2,
            code: ref v3,
        } => {
            if let &Opcode::Trap = v2 {
                let v4 = &constructor_pulley_trap(ctx, v3);
                let v5 = constructor_side_effect(ctx, v4);
                let v6 = Some(v5);
                // Rule at src/isa/pulley_shared/lower.isle line 56.
                return v6;
            }
        }
        &InstructionData::UnaryImm {
            opcode: ref v103,
            imm: v104,
        } => {
            if let &Opcode::Iconst = v103 {
                let v100 = C::first_result(ctx, arg0);
                if let Some(v101) = v100 {
                    let v102 = C::value_type(ctx, v101);
                    let v105 = C::u64_from_imm64(ctx, v104);
                    let v106 = constructor_imm(ctx, v102, v105);
                    let v107 = constructor_output_reg(ctx, v106);
                    let v108 = Some(v107);
                    // Rule at src/isa/pulley_shared/lower.isle line 152.
                    return v108;
                }
            }
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term lower_branch.
pub fn constructor_lower_branch<C: Context>(
    ctx: &mut C,
    arg0: Inst,
    arg1: &MachLabelSlice,
) -> Option<Unit> {
    let v1 = &C::inst_data(ctx, arg0);
    match v1 {
        &InstructionData::BranchTable {
            opcode: ref v39,
            arg: v40,
            table: v41,
        } => {
            if let &Opcode::BrTable = v39 {
                let v42 = C::jump_table_targets(ctx, arg1);
                if let Some(v43) = v42 {
                    let v46 = constructor_put_in_xreg(ctx, v40);
                    let v47 = constructor_gen_br_table(ctx, v46, v43.0, &v43.1);
                    let v48 = Some(v47);
                    // Rule at src/isa/pulley_shared/lower.isle line 51.
                    return v48;
                }
            }
        }
        &InstructionData::Brif {
            opcode: ref v10,
            arg: v11,
            blocks: ref v12,
        } => {
            if let &Opcode::Brif = v10 {
                let v13 = C::maybe_uextend(ctx, v11);
                if let Some(v14) = v13 {
                    let v18 = C::two_targets(ctx, arg1);
                    if let Some(v19) = v18 {
                        let v26 = C::def_inst(ctx, v14);
                        if let Some(v27) = v26 {
                            let v28 = &C::inst_data(ctx, v27);
                            if let &InstructionData::IntCompare {
                                opcode: ref v29,
                                args: ref v30,
                                cond: ref v31,
                            } = v28
                            {
                                if let &Opcode::Icmp = v29 {
                                    let v32 = C::unpack_value_array_2(ctx, v30);
                                    let v35 = C::value_type(ctx, v32.1);
                                    if v35 == I32 {
                                        let v36 = &constructor_lower_brif_of_icmp32(
                                            ctx, v31, v32.0, v32.1, v19.0, v19.1,
                                        );
                                        let v37 = constructor_emit_side_effect(ctx, v36);
                                        let v38 = Some(v37);
                                        // Rule at src/isa/pulley_shared/lower.isle line 21.
                                        return v38;
                                    }
                                }
                            }
                        }
                        let v22 = constructor_put_in_xreg(ctx, v14);
                        let v23 = &constructor_pulley_br_if(ctx, v22, v19.0, v19.1);
                        let v24 = constructor_emit_side_effect(ctx, v23);
                        let v25 = Some(v24);
                        // Rule at src/isa/pulley_shared/lower.isle line 17.
                        return v25;
                    }
                }
            }
        }
        &InstructionData::Jump {
            opcode: ref v2,
            destination: v3,
        } => {
            if let &Opcode::Jump = v2 {
                let v5 = C::single_target(ctx, arg1);
                if let Some(v6) = v5 {
                    let v7 = &constructor_pulley_jump(ctx, v6);
                    let v8 = constructor_emit_side_effect(ctx, v7);
                    let v9 = Some(v8);
                    // Rule at src/isa/pulley_shared/lower.isle line 13.
                    return v9;
                }
            }
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term lower_brif_of_icmp32.
pub fn constructor_lower_brif_of_icmp32<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: Value,
    arg2: Value,
    arg3: MachLabel,
    arg4: MachLabel,
) -> SideEffectNoResult {
    match arg0 {
        &IntCC::Equal => {
            let v5 = constructor_put_in_xreg(ctx, arg1);
            let v6 = constructor_put_in_xreg(ctx, arg2);
            let v7 = &constructor_pulley_br_if_xeq32(ctx, v5, v6, arg3, arg4);
            // Rule at src/isa/pulley_shared/lower.isle line 26.
            return v7.clone();
        }
        &IntCC::NotEqual => {
            let v5 = constructor_put_in_xreg(ctx, arg1);
            let v6 = constructor_put_in_xreg(ctx, arg2);
            let v8 = &constructor_pulley_br_if_xneq32(ctx, v5, v6, arg3, arg4);
            // Rule at src/isa/pulley_shared/lower.isle line 28.
            return v8.clone();
        }
        &IntCC::SignedGreaterThan => {
            let v14 = &constructor_lower_brif_of_icmp32(
                ctx,
                &IntCC::SignedLessThan,
                arg2,
                arg1,
                arg3,
                arg4,
            );
            // Rule at src/isa/pulley_shared/lower.isle line 41.
            return v14.clone();
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v16 = &constructor_lower_brif_of_icmp32(
                ctx,
                &IntCC::SignedLessThanOrEqual,
                arg2,
                arg1,
                arg3,
                arg4,
            );
            // Rule at src/isa/pulley_shared/lower.isle line 43.
            return v16.clone();
        }
        &IntCC::SignedLessThan => {
            let v5 = constructor_put_in_xreg(ctx, arg1);
            let v6 = constructor_put_in_xreg(ctx, arg2);
            let v9 = &constructor_pulley_br_if_xslt32(ctx, v5, v6, arg3, arg4);
            // Rule at src/isa/pulley_shared/lower.isle line 30.
            return v9.clone();
        }
        &IntCC::SignedLessThanOrEqual => {
            let v5 = constructor_put_in_xreg(ctx, arg1);
            let v6 = constructor_put_in_xreg(ctx, arg2);
            let v10 = &constructor_pulley_br_if_xslteq32(ctx, v5, v6, arg3, arg4);
            // Rule at src/isa/pulley_shared/lower.isle line 32.
            return v10.clone();
        }
        &IntCC::UnsignedGreaterThan => {
            let v18 = &constructor_lower_brif_of_icmp32(
                ctx,
                &IntCC::UnsignedLessThan,
                arg2,
                arg1,
                arg3,
                arg4,
            );
            // Rule at src/isa/pulley_shared/lower.isle line 45.
            return v18.clone();
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v20 = &constructor_lower_brif_of_icmp32(
                ctx,
                &IntCC::UnsignedLessThanOrEqual,
                arg2,
                arg1,
                arg3,
                arg4,
            );
            // Rule at src/isa/pulley_shared/lower.isle line 47.
            return v20.clone();
        }
        &IntCC::UnsignedLessThan => {
            let v5 = constructor_put_in_xreg(ctx, arg1);
            let v6 = constructor_put_in_xreg(ctx, arg2);
            let v11 = &constructor_pulley_br_if_xult32(ctx, v5, v6, arg3, arg4);
            // Rule at src/isa/pulley_shared/lower.isle line 34.
            return v11.clone();
        }
        &IntCC::UnsignedLessThanOrEqual => {
            let v5 = constructor_put_in_xreg(ctx, arg1);
            let v6 = constructor_put_in_xreg(ctx, arg2);
            let v12 = &constructor_pulley_br_if_xulteq32(ctx, v5, v6, arg3, arg4);
            // Rule at src/isa/pulley_shared/lower.isle line 36.
            return v12.clone();
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "lower_brif_of_icmp32", "src/isa/pulley_shared/lower.isle line 25"
    )
}

// Generated as internal constructor for term lower_icmp.
pub fn constructor_lower_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> XReg {
    match arg1 {
        &IntCC::Equal => {
            match arg0 {
                I32 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v12 = constructor_pulley_xeq32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 196.
                    return v12;
                }
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v6 = constructor_pulley_xeq64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 178.
                    return v6;
                }
                _ => {}
            }
        }
        &IntCC::NotEqual => {
            match arg0 {
                I32 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v13 = constructor_pulley_xneq32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 199.
                    return v13;
                }
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v7 = constructor_pulley_xneq64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 181.
                    return v7;
                }
                _ => {}
            }
        }
        &IntCC::SignedGreaterThan => {
            let v19 = constructor_lower_icmp(ctx, arg0, &IntCC::SignedLessThan, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 216.
            return v19;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v21 = constructor_lower_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 218.
            return v21;
        }
        &IntCC::SignedLessThan => {
            match arg0 {
                I32 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v14 = constructor_pulley_xslt32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 202.
                    return v14;
                }
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v8 = constructor_pulley_xslt64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 184.
                    return v8;
                }
                _ => {}
            }
        }
        &IntCC::SignedLessThanOrEqual => {
            match arg0 {
                I32 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v15 = constructor_pulley_xslteq32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 205.
                    return v15;
                }
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v9 = constructor_pulley_xslteq64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 187.
                    return v9;
                }
                _ => {}
            }
        }
        &IntCC::UnsignedGreaterThan => {
            let v23 = constructor_lower_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 220.
            return v23;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v25 =
                constructor_lower_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 222.
            return v25;
        }
        &IntCC::UnsignedLessThan => {
            match arg0 {
                I32 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v16 = constructor_pulley_xult32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 208.
                    return v16;
                }
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v10 = constructor_pulley_xult64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 190.
                    return v10;
                }
                _ => {}
            }
        }
        &IntCC::UnsignedLessThanOrEqual => {
            match arg0 {
                I32 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v17 = constructor_pulley_xulteq32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 211.
                    return v17;
                }
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v11 = constructor_pulley_xulteq64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 193.
                    return v11;
                }
                _ => {}
            }
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "lower_icmp", "src/isa/pulley_shared/lower.isle line 176"
    )
}

// Generated as internal constructor for term lower_stack_addr.
pub fn constructor_lower_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: StackSlot,
    arg1: Offset32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = C::writable_xreg_to_writable_reg(ctx, v2);
    let v4 = &C::abi_stackslot_addr(ctx, v3, arg0, arg1);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/lower.isle line 247.
    return v6;
}
